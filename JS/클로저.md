## 클로저(closure)

코드가 진행되면서 **실행 컨텍스트** 형성돼 선언된 함수와 변수에 대한 정보들을 저장된다. 실행컨텍스트가 생성되면 그 안에 **함수에서 사용하는 변수를 객체에 저장**하는데, 그 객체가 **렉시컬 환경**이다.

클로저 개념도 렉시컬 환경에 근거하여 동작한다. **클로저는 함수가 자신의 렉시컬 환경을 기억하고 외부 스코프의 변수에 접근한다.**

**함수가 정의된 위치를 기준**으로 형성된 스코프에 따라 변수를 찾는다.
이때, **정의된 위치에 결정되는 스코프 = 렉시컬 스코프 = 클로저**이다.

해당 변수는 클로저를 가지고 있는 함수가 호출되어야만 접근이 가능하기 때문에 **정보 은닉에 활용**된다.

일반적으로 함수가 종료되면 메모리 환경이 사라지는 반면, **클로저는 함수가 종료돼도 메모리가 사라지지 않고 변수에 접근 가능하다.**

**클로저를 활용한 예시 **
counter 함수는 count라는 변수를 선언하고 plus 함수를 반환한다. 반환된 함수는 count 변수에 접근할 수 있기 때문에 매번 호출될 때마다 카운터 값을 1씩 증가 후 값을 반환한다.

```js
function counter() {
  let count = 0;
  return function plus() {
    count++;
    return count;
  };
}

const c1 = counter();
const c2 = counter();

console.log(c1()); // 1
console.log(c2()); // 2
```

### React Hook 에서 어떻게 클로저가 쓰이나요?

자바스크립트 클로저 개념이 `useState`에 활용되고 있다.

> **useState**
> 함수형 컴포넌트 내의 상태를 관리하는 React Hook

```js
const [value, setValue] = useState(0);
```

#### 클로저를 이용한 useState 구현

```js
const useState = (initValue) => {
  let value = initValue;
  const setValue = (newValue) => {
    value = newValue;
  };
  return [value, setValue];
};

/**
실제 앱에서는 예시 코드에 리랜더링과 상태 업데이트를 올바르게 처리하기 위한 추가 설정이 필요하다.
*/
```

1. useState 함수는 초기값 initValue를 받고 로컬 변수 value를 해당 값으로 초기화한다.

2)setValue 함수는 value 변수를 newValue로 업데이트한다. 이 함수는 클로저를 형성하며, value 변수를 저장한다.

3. useState 함수는 현재 상태 (value)와 상태 업데이트 함수 (setValue)를 포함하는 배열을 반환한다.

### 클로저를 사용하는 이유

컴포넌트가 렌더링될 때마다 새로운 useState Hook 인스턴스가 생성되는 것이 아니라 **동일한 클로저 함수를 재사용한다는 것**을 의미한다. 덕분에 **이전 렌더링에서 설정된 상태 값을 유지하고 액세스할 수 있다.**

### 마무리

자바스크립트 클로저와 리액트 훅 `useState`와의 관계를 이해하기 위해 간단한 예제와 함께 클로저의 작동 방식을 공부해보았다.

이론으로만 알고 있었던 클로저 개념을 사용해서 리액트가 어떻게 `useState`로 상태를 관리하고 컴포넌트를 효율적으로 업데이트하는지 이해할 수 있었다.

## 참고

[React hooks : UseState creates a closure
](https://youtu.be/zBNJCtbF6T0?si=1rBzmEhSbSIMv3NN)
